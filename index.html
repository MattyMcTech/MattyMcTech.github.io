<html><head><!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-6FHMG8SXV6"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-6FHMG8SXV6');
</script><base href="https://wordsmasher.io/"><title>WordSmasher - Cowboy vs Zombies</title><style>
@import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@700&display=swap');

body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: 'Roboto', sans-serif;
    background-color: #1a1a1a;
    color: #fff;
    overflow: hidden;
}
#game-container {
    width: 100%;
    height: 100%;
    position: relative;
    background: url('https://example.com/zombie-western-background.jpg') no-repeat center center fixed;
    background-size: cover;
}
#player {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 80px;
    height: 80px;
    background: url('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/cowboy.png') no-repeat center center;
    background-size: contain;
    z-index: 1000;
}
.enemy-word {
    position: absolute;
    font-size: 28px;
    font-weight: bold;
    color: #4CAF50;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 5px #4CAF50;
    transition: all 0.1s;
}
.enemy-word span {
    transition: color 0.2s;
}
.enemy-word span.hit {
    color: #FF6347;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 10px #FF6347;
}
.enemy-word.dazed {
    animation: daze 0.5s ease-in-out;
}
@keyframes daze {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px) rotate(-5deg); }
    75% { transform: translateX(5px) rotate(5deg); }
}
#typed-word {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 36px;
    font-family: 'Creepster', cursive;
    color: #FFD700;
    text-shadow: 0 0 10px #FFD700;
}
#score, #total-score, #wave, #words-left {
    position: absolute;
    font-size: 32px;
    font-family: 'Creepster', cursive;
    color: #FF6347;
    text-shadow: 0 0 5px #FF6347;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 5px 10px;
    border-radius: 10px;
}
#score { top: 10px; right: 10px; }
#total-score { top: 50px; right: 10px; }
#wave { top: 10px; left: 10px; }
#words-left { top: 50px; left: 10px; font-size: 24px; }
#game-over, #wave-complete {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 72px;
    font-family: 'Creepster', cursive;
    display: none;
    text-align: center;
    color: #FF6347;
    text-shadow: 0 0 15px #FF6347;
    z-index: 2000;
}
#game-over {
    background-color: rgba(0, 0, 0, 0.8);
    padding: 40px;
    border-radius: 20px;
    box-shadow: 0 0 20px #FF6347;
}
#game-over h2 {
    margin: 0 0 20px 0;
}
#final-score {
    font-size: 48px;
    margin-bottom: 20px;
}
#wave-complete {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
#wave-complete h2 {
    margin: 0 0 20px 0;
}
#next-wave-btn, #restart-btn {
    font-family: 'Creepster', cursive;
    font-size: 36px;
    padding: 10px 20px;
    background-color: #8B4513;
    color: #FFD700;
    border: none;
    cursor: pointer;
    text-shadow: 0 0 5px #FFD700;
    box-shadow: 0 0 10px #8B4513;
}
.bullet {
    position: absolute;
    width: 20px;
    height: 20px;
    background: url('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/bullet.png') no-repeat center center;
    background-size: contain;
    z-index: 999;
}
.blood-splatter {
    position: absolute;
    width: 100px;
    height: 100px;
    background: url('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/bloodAni1.gif') no-repeat center center;
    background-size: contain;
    pointer-events: none;
    z-index: 1001;
}
#mute-btn, #pause-btn {
    position: absolute;
    bottom: 10px;
    font-family: 'Creepster', cursive;
    font-size: 24px;
    padding: 5px 10px;
    background-color: #8B4513;
    color: #FFD700;
    border: none;
    cursor: pointer;
    text-shadow: 0 0 5px #FFD700;
    box-shadow: 0 0 10px #8B4513;
}
#mute-btn { left: 10px; }
#pause-btn { right: 10px; }
#wave-cleared {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 72px;
    font-family: 'Creepster', cursive;
    text-align: center;
    color: #FFD700;
    text-shadow: 0 0 15px #FFD700;
    z-index: 2001;
    display: none;
    background-color: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 20px;
}
#wave-cleared p {
    margin: 10px 0;
    font-size: 48px;
}
#debug-info {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: #FFD700;
    padding: 5px 10px;
    border-radius: 5px;
    font-family: 'Roboto', sans-serif;
    font-size: 14px;
}
</style></head><body>
<div id="game-container">
    <div id="player"></div>
    <div id="typed-word"></div>
    <div id="score">Zombies Shot: <span id="score-value">0</span></div>
    <div id="total-score">Score: <span id="total-score-value">0</span></div>
    <div id="wave">Zombie Wave: <span id="wave-value">1</span></div>
    <div id="words-left">Zombies Left: <span id="words-left-value">5</span></div>
    <div id="game-over">
        <h2>YEEHAW TURNED TO BRAAAINS</h2>
        <div id="final-score">Final Score: <span id="final-score-value">0</span></div>
        <button id="restart-btn">Restart Game</button>
    </div>
    <div id="wave-complete">
        <h2>Wave Cleared, Pardner!</h2>
        <button id="next-wave-btn">Next Wave</button>
    </div>
    <div id="wave-cleared">
        Wave Cleared, Pardner!
        <p>Score: <span id="wave-score">0</span></p>
    </div>
    <button id="mute-btn">Mute Sound</button>
    <button id="pause-btn">Pause</button>
    <div></div>
</div>

<script>
const gameContainer = document.getElementById('game-container');
const typedWord = document.getElementById('typed-word');
const scoreValue = document.getElementById('score-value');
const totalScoreValue = document.getElementById('total-score-value');
const waveValue = document.getElementById('wave-value');
const wordsLeftValue = document.getElementById('words-left-value');
const gameOver = document.getElementById('game-over');
const waveComplete = document.getElementById('wave-complete');
const nextWaveBtn = document.getElementById('next-wave-btn');
const restartBtn = document.getElementById('restart-btn');
const player = document.getElementById('player');
const muteBtn = document.getElementById('mute-btn');
const pauseBtn = document.getElementById('pause-btn');
const waveCleared = document.getElementById('wave-cleared');
const waveScore = document.getElementById('wave-score');
const debugInfo = document.getElementById('debug-info');
const finalScoreValue = document.getElementById('final-score-value');

const splatSound = new Audio('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/splat.mp3');
splatSound.volume = 0.5;

let zombiesShot = 0;
let totalScore = 0;
let words = [];
let currentWave = 1;
let waveWordCount = 5;
let wordSpeed = 1.0;
let baseSpawnRate = 1500;
let wordsDefeated = 0;
let wordsSpawned = 0;
let currentTypedWord = '';
let currentTargetWord = null;
let isGameActive = false;
let gameInterval;
let isMuted = false;
let isPaused = false;
let lettersHitThisWave = 0;

function updateDebugInfo() {
    debugInfo.textContent = `Words: ${words.length}, Spawned: ${wordsSpawned}, Defeated: ${wordsDefeated}, Target: ${currentTargetWord ? currentTargetWord.word : 'None'}`;
}

muteBtn.addEventListener('click', () => {
    isMuted = !isMuted;
    muteBtn.textContent = isMuted ? 'Unmute Sound' : 'Mute Sound';
    splatSound.muted = isMuted;
});

pauseBtn.addEventListener('click', () => {
    isPaused = !isPaused;
    pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
    if (isPaused) {
        clearInterval(gameInterval);
    } else {
        gameInterval = setInterval(moveWords, 33);
    }
});

async function getRandomWord(minLength, maxLength) {
    const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
    try {
        const response = await fetch(`https://random-word-api.herokuapp.com/word?length=${length}`);
        if (!response.ok) {
            throw new Error('Failed to fetch word');
        }
        const data = await response.json();
        return data[0];
    } catch (error) {
        console.error('Error fetching word:', error);
        return fallbackGetRandomWord(length);
    }
}

function fallbackGetRandomWord(length) {
    const characters = 'abcdefghijklmnopqrstuvwxyz';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}

async function spawnWord() {
    if (wordsSpawned >= waveWordCount) return;
    
    let minLength, maxLength;
    if (currentWave <= 3) {
        minLength = 3;
        maxLength = 5;
    } else if (currentWave <= 6) {
        minLength = 3;
        maxLength = 7;
    } else {
        minLength = 3;
        maxLength = 10;
    }
    
    const word = await getRandomWord(minLength, maxLength);
    const wordElement = document.createElement('div');
    wordElement.classList.add('enemy-word');
    word.split('').forEach(letter => {
        const span = document.createElement('span');
        span.textContent = letter;
        wordElement.appendChild(span);
    });

    let position;
    let attempts = 0;
    do {
        position = getRandomEdgePosition();
        attempts++;
    } while (isOverlapping(position.x, position.y) && attempts < 10);

    if (attempts >= 10) {
        console.log("Failed to find non-overlapping position");
        return;
    }

    wordElement.style.left = `${position.x}px`;
    wordElement.style.top = `${position.y}px`;
    
    const individualWordSpeed = wordSpeed * (1 + (word.length - minLength) * 0.1);
    
    gameContainer.appendChild(wordElement);
    words.push({ element: wordElement, word, hitIndex: 0, x: position.x, y: position.y, speed: individualWordSpeed, bulletsInFlight: 0 });
    wordsSpawned++;
    updateWordsLeft();
    updateDebugInfo();
}

function getRandomEdgePosition() {
    const edge = Math.floor(Math.random() * 4);
    const x = Math.random() * window.innerWidth;
    const y = Math.random() * window.innerHeight;
    switch (edge) {
        case 0: return { x: x, y: 0 };
        case 1: return { x: window.innerWidth, y: y };
        case 2: return { x: x, y: window.innerHeight };
        case 3: return { x: 0, y: y };
    }
}

function isOverlapping(x, y) {
    const buffer = 50;
    return words.some(word => {
        const dx = word.x - x;
        const dy = word.y - y;
        return Math.sqrt(dx * dx + dy * dy) < buffer;
    });
}

function spawnWordWithDelay() {
    if (wordsSpawned < waveWordCount && isGameActive && !isPaused) {
        spawnWord();
        if (wordsSpawned < waveWordCount) {
            const delay = Math.min(1000, baseSpawnRate + Math.random() * 500);
            setTimeout(spawnWordWithDelay, delay);
        }
    }
}

function moveWords() {
    if (isPaused) return;

    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    words.forEach((wordObj) => {
        const dx = centerX - wordObj.x;
        const dy = centerY - wordObj.y;const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
            const ratio = wordObj.speed / distance;
            wordObj.x += dx * ratio;
            wordObj.y += dy * ratio;
            
            wordObj.element.style.left = `${wordObj.x}px`;
            wordObj.element.style.top = `${wordObj.y}px`;
        } else {
            endGame();
        }
    });
    updateDebugInfo();
}

function updateTypedWord(key) {
    if (!isGameActive || isPaused) return;

    if (!currentTargetWord || !words.includes(currentTargetWord)) {
        const visibleWords = getVisibleWords();
        const matchingWords = visibleWords.filter(w => w.word[0].toLowerCase() === key.toLowerCase());
        
        if (matchingWords.length > 0) {
            const playerRect = player.getBoundingClientRect();
            const playerCenterX = playerRect.left + playerRect.width / 2;
            const playerCenterY = playerRect.top + playerRect.height / 2;

            currentTargetWord = matchingWords.reduce((closest, current) => {
                const closestRect = closest.element.getBoundingClientRect();
                const currentRect = current.element.getBoundingClientRect();

                const closestDistance = Math.sqrt(
                    Math.pow(closestRect.left + closestRect.width / 2 - playerCenterX, 2) +
                    Math.pow(closestRect.top + closestRect.height / 2 - playerCenterY, 2)
                );

                const currentDistance = Math.sqrt(
                    Math.pow(currentRect.left + currentRect.width / 2 - playerCenterX, 2) +
                    Math.pow(currentRect.top + currentRect.height / 2 - playerCenterY, 2)
                );

                return currentDistance < closestDistance ? current : closest;
            });
        } else {
            currentTargetWord = null;
            currentTypedWord = '';
            typedWord.textContent = '';
            return;
        }
    }

    if (currentTargetWord && currentTargetWord.hitIndex < currentTargetWord.word.length && 
        currentTargetWord.word[currentTargetWord.hitIndex].toLowerCase() === key.toLowerCase()) {
        currentTypedWord += key;
        currentTargetWord.element.children[currentTargetWord.hitIndex].classList.add('hit');
        currentTargetWord.hitIndex++;
        shootBullet(currentTargetWord);
        currentTargetWord.bulletsInFlight++;
        lettersHitThisWave++;
        totalScore++;
        updateTotalScore();
        
        if (currentTargetWord.hitIndex === currentTargetWord.word.length) {
            currentTypedWord = '';
            currentTargetWord = null;
        }
    }

    typedWord.textContent = currentTypedWord;
    updateDebugInfo();
}

function updateTotalScore() {
    totalScoreValue.textContent = totalScore;
}

function handleWordCompletion(targetWord) {
    zombiesShot++;
    scoreValue.textContent = zombiesShot;
    wordsDefeated++;
    
    const rect = targetWord.element.getBoundingClientRect();
    playBloodSplatter(rect.left + rect.width / 2, rect.top + rect.height / 2);
    
    if (!isMuted) {
        splatSound.currentTime = 0;
        splatSound.play();
    }
    
    words = words.filter(w => w !== targetWord);
    targetWord.element.remove();
    updateWordsLeft();
    checkWaveCompletion();
    updateDebugInfo();
}

function dazeWord(wordObj) {
    wordObj.element.classList.add('dazed');
    wordObj.speed *= 0.5;
    setTimeout(() => {
        wordObj.element.classList.remove('dazed');
        wordObj.speed = wordSpeed * (1 + (wordObj.word.length - 3) * 0.1);
    }, 1000);
}

function checkWaveCompletion() {
    if (wordsDefeated >= waveWordCount) {
        clearInterval(gameInterval);
        isGameActive = false;
        showWaveClearedPopup();
    } else if (words.length === 0 && wordsSpawned < waveWordCount) {
        spawnWordWithDelay();
    }
    updateDebugInfo();
}

function showWaveClearedPopup() {
    waveScore.textContent = lettersHitThisWave;
    waveCleared.style.display = 'block';
    setTimeout(() => {
        waveCleared.style.display = 'none';
        startNextWave();
    }, 3000);
}

function startNextWave() {
    currentWave++;
    waveWordCount += 1;
    wordSpeed += 0.1;
    baseSpawnRate = Math.max(500, baseSpawnRate - 100);
    lettersHitThisWave = 0;
    startWave();
}

function isElementInViewport(el) {
    const rect = el.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
}

function getVisibleWords() {
    return words.filter(({ element }) => isElementInViewport(element));
}

function updateWordsLeft() {
    wordsLeftValue.textContent = waveWordCount - wordsDefeated;
}

function shootBullet(targetWord) {
    const bullet = document.createElement('div');
    bullet.classList.add('bullet');
    const playerRect = player.getBoundingClientRect();
    const wordRect = targetWord.element.getBoundingClientRect();

    const startX = playerRect.left + playerRect.width / 2;
    const startY = playerRect.top + playerRect.height / 2;
    const endX = wordRect.left + wordRect.width / 2;
    const endY = wordRect.top + wordRect.height / 2;

    bullet.style.left = `${startX}px`;
    bullet.style.top = `${startY}px`;

    const angle = Math.atan2(endY - startY, endX - startX) * (180 / Math.PI);
    bullet.style.transform = `rotate(${angle + 90}deg)`;
    gameContainer.appendChild(bullet);

    const animationDuration = 500;
    const startTime = Date.now();

    function animateBullet() {
        const elapsedTime = Date.now() - startTime;
        const progress = Math.min(elapsedTime / animationDuration, 1);

        const currentX = startX + (endX - startX) * progress;
        const currentY = startY + (endY - startY) * progress;

        bullet.style.left = `${currentX - bullet.offsetWidth / 2}px`;
        bullet.style.top = `${currentY - bullet.offsetHeight / 2}px`;

        if (progress < 1) {
            requestAnimationFrame(animateBullet);
        } else {
            bullet.remove();
            targetWord.bulletsInFlight--;
            dazeWord(targetWord);
            
            if (targetWord.bulletsInFlight === 0 && targetWord.hitIndex === targetWord.word.length) {
                handleWordCompletion(targetWord);
            }
        }
    }

    requestAnimationFrame(animateBullet);
}

function playBloodSplatter(x, y) {
    const bloodSplatter = document.createElement('div');
    bloodSplatter.classList.add('blood-splatter');
    bloodSplatter.style.left = `${x - 50}px`;
    bloodSplatter.style.top = `${y - 50}px`;
    gameContainer.appendChild(bloodSplatter);

    setTimeout(() => {
        bloodSplatter.remove();
    }, 1000);
}

document.addEventListener('keydown', (event) => {
    if (!isGameActive || isPaused) return;

    if (event.key === 'Backspace') {
        if (currentTypedWord.length > 0) {
            currentTypedWord = currentTypedWord.slice(0, -1);
            if (currentTargetWord) {
                currentTargetWord.hitIndex--;
                currentTargetWord.element.children[currentTargetWord.hitIndex].classList.remove('hit');
            }
            if (currentTypedWord.length === 0) {
                currentTargetWord = null;
            }
        }
    } else if (event.key.length === 1) {
        updateTypedWord(event.key);
    }
    typedWord.textContent = currentTypedWord;
    updateDebugInfo();
});

function startWave() {
    isGameActive = true;
    wordsDefeated = 0;
    wordsSpawned = 0;
    words.forEach(({ element }) => element.remove());
    words = [];
    currentTypedWord = '';
    currentTargetWord = null;
    typedWord.textContent = '';
    waveComplete.style.display = 'none';
    gameOver.style.display = 'none';
    waveValue.textContent = currentWave;
    updateWordsLeft();

    gameInterval = setInterval(moveWords, 33);
    spawnWordWithDelay();
    updateDebugInfo();
}

function endGame() {
    isGameActive = false;
    clearInterval(gameInterval);
    finalScoreValue.textContent = totalScore;
    gameOver.style.display = 'flex';
    updateDebugInfo();
}

restartBtn.addEventListener('click', () => {
    zombiesShot = 0;
    totalScore = 0;
    scoreValue.textContent = zombiesShot;
    totalScoreValue.textContent = totalScore;
    currentWave = 1;
    waveWordCount = 5;
    wordSpeed = 1.0;
    baseSpawnRate = 1500;
    lettersHitThisWave = 0;
    startWave();
});

function initGame() {
    zombiesShot = 0;
    totalScore = 0;
    scoreValue.textContent = zombiesShot;
    totalScoreValue.textContent = totalScore;
    currentWave = 1;
    waveWordCount = 5;
    wordSpeed = 1.0;
    baseSpawnRate = 1500;
    lettersHitThisWave = 0;
    startWave();
}

initGame();</script>

<a href="https://wordsmasher.io/leaderboard" style="color: #FFD700; text-shadow: 0 0 5px #FFD700;">Zombie Slayer Hall of Fame</a>
<a href="https://wordsmasher.io/tutorial" style="color: #FFD700; text-shadow: 0 0 5px #FFD700;">Cowboy Survival Guide</a>
<a href="https://wordsmasher.io/settings" style="color: #FFD700; text-shadow: 0 0 5px #FFD700;">Apocalypse Settings</a>
</body></html>
