<html><head><base href="https://wordsmasher.io/"><title>WordSmasher - Cowboy vs Zombies</title><style>
@import url('https://fonts.googleapis.com/css2?family=Creepster&family=Roboto:wght@700&display=swap');

body, html {
    margin: 0;
    padding: 0;
    height: 100%;
    font-family: 'Roboto', sans-serif;
    background-color: #1a1a1a;
    color: #fff;
    overflow: hidden;
}
#game-container {
    width: 100%;
    height: 100%;
    position: relative;
    background: url('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/map.png') no-repeat center center fixed;
    background-size: cover;
}
#player {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    width: 80px;
    height: 80px;
    background: url('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/cowboy.png') no-repeat center center;
    background-size: contain;
    z-index: 1000;
}
.enemy-word {
    position: absolute;
    font-size: 28px;
    font-weight: bold;
    color: #4CAF50;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 5px #4CAF50;
    transition: all 0.1s;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 5px 10px;
    border-radius: 5px;
    opacity: 0;
    transition: opacity 0.5s;
}
.enemy-word.visible {
    opacity: 1;
}
.enemy-word span {
    transition: color 0.2s;
}
.enemy-word span.hit {
    color: #FF6347;
    text-shadow: -1px -1px 0 #000, 1px -1px 0 #000, -1px 1px 0 #000, 1px 1px 0 #000, 0 0 10px #FF6347;
}
.enemy-word.dazed {
    animation: daze 0.5s ease-in-out;
}
.bullseye {
    position: absolute;
    bottom: -10px;
    right: -10px;
    width: 20px;
    height: 20px;
    background: radial-gradient(circle, red 0%, red 30%, white 30%, white 60%, red 60%, red 100%);
    border-radius: 50%;
}
@keyframes daze {
    0%, 100% { transform: translateX(0); }
    25% { transform: translateX(-5px) rotate(-5deg); }
    75% { transform: translateX(5px) rotate(5deg); }
}
#typed-word {
    position: absolute;
    bottom: 20px;
    left: 50%;
    transform: translateX(-50%);
    font-size: 36px;
    font-family: 'Creepster', cursive;
    color: #FFD700;
    text-shadow: 0 0 10px #FFD700;
}
#score, #total-score, #wave, #words-left {
    position: absolute;
    font-size: 32px;
    font-family: 'Creepster', cursive;
    color: #FF6347;
    text-shadow: 0 0 5px #FF6347;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 5px 10px;
    border-radius: 10px;
}
#score { top: 10px; right: 10px; }
#total-score { top: 50px; right: 10px; }
#wave { top: 10px; left: 10px; }
#words-left { top: 50px; left: 10px; font-size: 24px; }
#game-over, #wave-complete {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    font-family: 'Roboto', sans-serif;
    display: none;
    text-align: center;
    color: #FFFFFF;
    text-shadow: 0 0 10px #000000;
    z-index: 2000;
}
#game-over {
    background-color: rgba(0, 0, 0, 0.8);
    padding: 40px;
    border-radius: 20px;
    box-shadow: 0 0 20px #FF6347;
    display: flex;
    flex-direction: column;
    align-items: center;
}
#game-over h2 {
    margin: 0 0 20px 0;
    font-size: 64px;
    font-weight: bold;
}
#final-score {
    font-size: 36px;
    margin-bottom: 20px;
}
#wave-complete {
    display: flex;
    flex-direction: column;
    align-items: center;
    justify-content: center;
}
#wave-complete h2 {
    margin: 0 0 20px 0;
}
#next-wave-btn, #restart-btn {
    font-family: 'Roboto', sans-serif;
    font-size: 24px;
    padding: 10px 20px;
    background-color: #4CAF50;
    color: #FFFFFF;
    border: none;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s;
}
#next-wave-btn:hover, #restart-btn:hover {
    background-color: #45a049;
}
.bullet {
    position: absolute;
    width: 20px;
    height: 20px;
    background: url('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/bullet.png') no-repeat center center;
    background-size: contain;
    z-index: 999;
}
.blood-splatter {
    position: absolute;
    width: 100px;
    height: 100px;
    background: url('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/bloodAni1.gif') no-repeat center center;
    background-size: contain;
    pointer-events: none;
    z-index: 1001;
}
#mute-btn, #pause-btn {
    position: absolute;
    bottom: 10px;
    font-family: 'Roboto', sans-serif;
    font-size: 18px;
    padding: 5px 10px;
    background-color: #4CAF50;
    color: #FFFFFF;
    border: none;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s;
}
#start-game-btn {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 2000;
    font-family: 'Roboto', sans-serif;
    font-size: 24px;
    padding: 10px 20px;
    background-color: #4CAF50;
    color: #FFFFFF;
    border: none;
    cursor: pointer;
    border-radius: 5px;
    transition: background-color 0.3s;
}
#mute-btn:hover, #pause-btn{
    background-color: #45a049;
}
#start-game-btn:hover {
    background-color: #45a049;
}
#mute-btn { left: 10px; }
#pause-btn { right: 10px; }
#wave-cleared {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    font-size: 48px;
    font-family: 'Roboto', sans-serif;
    text-align: center;
    color: #FFFFFF;
    text-shadow: 0 0 10px #000000;
    z-index: 2001;
    display: none;
    background-color: rgba(0, 0, 0, 0.8);
    padding: 20px;
    border-radius: 20px;
}
#wave-cleared p {
    margin: 10px 0;
    font-size: 36px;
}
#debug-info {
    position: absolute;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    background-color: rgba(0, 0, 0, 0.7);
    color: #FFD700;
    padding: 5px 10px;
    border-radius: 5px;
    font-family: 'Roboto', sans-serif;
    font-size: 14px;
}
</style></head><body>
<div id="game-container">
    <div id="player"></div>
    <div id="typed-word"></div>
    <div id="score">Zombies Shot: <span id="score-value">0</span></div>
    <div id="total-score">Score: <span id="total-score-value">0</span></div>
    <div id="wave">Zombie Wave: <span id="wave-value">1</span></div>
    <div id="words-left">Zombies Left: <span id="words-left-value">5</span></div>
    <div id="game-over">
        <h2>GAME OVER</h2>
        <div id="final-score">Final Score: <span id="final-score-value">0</span></div>
        <button id="restart-btn">Restart Game</button>
    </div>
    <div id="wave-complete">
        <h2>Wave Cleared!</h2>
        <button id="next-wave-btn">Next Wave</button>
    </div>
    <div id="wave-cleared">
        Wave Cleared!
        <p>Score: <span id="wave-score">0</span></p>
    </div>
    <button id="mute-btn">Mute Sound</button>
    <button id="pause-btn">Pause</button>
    <button id="start-game-btn">Start Game</button>
    <div id="debug-info"></div>
</div>

<script>
const gameContainer = document.getElementById('game-container');
const typedWord = document.getElementById('typed-word');
const scoreValue = document.getElementById('score-value');
const totalScoreValue = document.getElementById('total-score-value');
const waveValue = document.getElementById('wave-value');
const wordsLeftValue = document.getElementById('words-left-value');
const gameOver = document.getElementById('game-over');
const waveComplete = document.getElementById('wave-complete');
const nextWaveBtn = document.getElementById('next-wave-btn');
const restartBtn = document.getElementById('restart-btn');
const player = document.getElementById('player');
const muteBtn = document.getElementById('mute-btn');
const pauseBtn = document.getElementById('pause-btn');
const waveCleared = document.getElementById('wave-cleared');
const waveScore = document.getElementById('wave-score');
const debugInfo = document.getElementById('debug-info');
const finalScoreValue = document.getElementById('final-score-value');
const startGameBtn = document.getElementById('start-game-btn');

const splatSound = new Audio('https://raw.githubusercontent.com/MattyMcTech/WordWarZ/main/splat.mp3');
splatSound.volume = 0.3;

const backgroundMusic = new Audio('https://github.com/MattyMcTech/WordWarZ/raw/main/song.mp3');
backgroundMusic.loop = true;
backgroundMusic.volume = 0.3;

const bulletHitSound = new Audio('https://github.com/MattyMcTech/WordWarZ/raw/main/bulletHit.mp3');
bulletHitSound.volume = 0.3;

const bulletShotSound = new Audio('https://github.com/MattyMcTech/WordWarZ/raw/main/bullet.mp3');
bulletShotSound.volume = 0.3;

let zombiesShot = 0;
let totalScore = 0;
let words = [];
let currentWave = 1;
let waveWordCount = 5;
let wordSpeed = 1.0;
let baseSpawnRate = 1500;
let wordsDefeated = 0;
let wordsSpawned = 0;
let currentTypedWord = '';
let currentTargetWord = null;
let isGameActive = false;
let gameInterval;
let isMuted = false;
let isPaused = false;
let lettersHitThisWave = 0;
let audioContext;
let musicStarted = false;

function updateDebugInfo() {
    debugInfo.textContent = `Words: ${words.length}, Spawned: ${wordsSpawned}, Defeated: ${wordsDefeated}, Target: ${currentTargetWord ? currentTargetWord.word : 'None'}`;
}

function debugLog(message) {
    console.log(`[DEBUG] ${message}`);
    if (debugInfo) {
        debugInfo.textContent += `\n${message}`;
    }
}

muteBtn.addEventListener('click', () => {
    isMuted = !isMuted;
    muteBtn.textContent = isMuted ? 'Unmute Sound' : 'Mute Sound';
    splatSound.muted = isMuted;
    backgroundMusic.muted = isMuted;
    bulletHitSound.muted = isMuted;
    bulletShotSound.muted = isMuted;
    
    if (isMuted) {
        backgroundMusic.pause();
    } else if (isGameActive) {
        playBackgroundMusic();
    }
});

pauseBtn.addEventListener('click', () => {
    isPaused = !isPaused;
    pauseBtn.textContent = isPaused ? 'Resume' : 'Pause';
    if (isPaused) {
        debugLog("Game paused, stopping music");
        clearInterval(gameInterval);
        backgroundMusic.pause();
    } else {
        debugLog("Game resumed, restarting music");
        gameInterval = setInterval(moveWords, 33);
        forcePlayMusic();
    }
});

backgroundMusic.addEventListener('play', () => {
    debugLog("Background music play event triggered");
});

backgroundMusic.addEventListener('playing', () => {
    debugLog("Background music is now playing");
});

backgroundMusic.addEventListener('pause', () => {
    debugLog("Background music paused");
});

backgroundMusic.addEventListener('error', (e) => {
    debugLog(`Background music error: ${e.target.error.message}`);
});

async function getRandomWord(minLength, maxLength) {
    const length = Math.floor(Math.random() * (maxLength - minLength + 1)) + minLength;
    try {
        const response = await fetch(`https://random-word-api.herokuapp.com/word?length=${length}`);
        if (!response.ok) {
            throw new Error('Failed to fetch word');
        }
        const data = await response.json();
        return data[0];
    } catch (error) {
        console.error('Error fetching word:', error);
        return fallbackGetRandomWord(length);
    }
}

function fallbackGetRandomWord(length) {
    const characters = 'abcdefghijklmnopqrstuvwxyz';
    let result = '';
    for (let i = 0; i < length; i++) {result += characters.charAt(Math.floor(Math.random() * characters.length));
    }
    return result;
}

async function spawnWord() {
    if (wordsSpawned >= waveWordCount) return;
    
    let minLength, maxLength;
    if (currentWave <= 5) {
        minLength = 3;
        maxLength = 5;
    } else if (currentWave <= 10) {
        minLength = 3;
        maxLength = 6;
    } else {
        minLength = 3;
        maxLength = 7;
    }
    
    const word = await getRandomWord(minLength, maxLength);
    const wordElement = document.createElement('div');
    wordElement.classList.add('enemy-word');
    word.split('').forEach(letter => {
        const span = document.createElement('span');
        span.textContent = letter;
        wordElement.appendChild(span);
    });

    const bullseye = document.createElement('div');
    bullseye.classList.add('bullseye');
    wordElement.appendChild(bullseye);

    const position = getRandomEdgePosition(wordElement);
    wordElement.style.left = `${position.x}px`;
    wordElement.style.top = `${position.y}px`;
    
    const individualWordSpeed = wordSpeed * (1 + (word.length - minLength) * 0.05);
    
    gameContainer.appendChild(wordElement);
    words.push({ element: wordElement, word, hitIndex: 0, x: position.x, y: position.y, speed: individualWordSpeed, bulletsInFlight: 0, isMoving: false });
    wordsSpawned++;
    updateWordsLeft();
    updateDebugInfo();

    // Make the word visible after a short delay
    setTimeout(() => {
        wordElement.classList.add('visible');
    }, 100);

    // Start moving the word after half a second
    setTimeout(() => {
        words[words.length - 1].isMoving = true;
    }, 500);
}

function getRandomEdgePosition(wordElement) {
    const containerRect = gameContainer.getBoundingClientRect();
    const wordRect = wordElement.getBoundingClientRect();
    const edge = Math.floor(Math.random() * 4);
    let x, y;

    switch (edge) {
        case 0: // Top edge
            x = Math.random() * (containerRect.width - wordRect.width);
            y = 0;
            break;
        case 1: // Right edge
            x = containerRect.width - wordRect.width;
            y = Math.random() * (containerRect.height - wordRect.height);
            break;
        case 2: // Bottom edge
            x = Math.random() * (containerRect.width - wordRect.width);
            y = containerRect.height - wordRect.height;
            break;
        case 3: // Left edge
            x = 0;
            y = Math.random() * (containerRect.height - wordRect.height);
            break;
    }

    return { x, y };
}

function spawnWordWithDelay() {
    if (wordsSpawned < waveWordCount && isGameActive && !isPaused) {
        spawnWord();
        if (wordsSpawned < waveWordCount) {
            const delay = Math.min(1500, baseSpawnRate + Math.random() * 750);
            setTimeout(spawnWordWithDelay, delay);
        }
    }
}

function moveWords() {
    if (isPaused) return;

    const centerX = window.innerWidth / 2;
    const centerY = window.innerHeight / 2;

    words.forEach((wordObj) => {
        if (!wordObj.isMoving) return;

        const dx = centerX - wordObj.x;
        const dy = centerY - wordObj.y;
        const distance = Math.sqrt(dx * dx + dy * dy);
        
        if (distance > 5) {
            const ratio = wordObj.speed / distance;
            wordObj.x += dx * ratio;
            wordObj.y += dy * ratio;
            
            wordObj.element.style.left = `${wordObj.x}px`;
            wordObj.element.style.top = `${wordObj.y}px`;
        } else {
            endGame();
        }
    });
    updateDebugInfo();
}

function updateTypedWord(key) {
    if (!isGameActive || isPaused) return;

    if (!currentTargetWord || !words.includes(currentTargetWord)) {
        const visibleWords = getVisibleWords();
        const matchingWords = visibleWords.filter(w => w.word[0].toLowerCase() === key.toLowerCase());
        
        if (matchingWords.length > 0) {
            const playerRect = player.getBoundingClientRect();
            const playerCenterX = playerRect.left + playerRect.width / 2;
            const playerCenterY = playerRect.top + playerRect.height / 2;

            currentTargetWord = matchingWords.reduce((closest, current) => {
                const closestRect = closest.element.getBoundingClientRect();
                const currentRect = current.element.getBoundingClientRect();

                const closestDistance = Math.sqrt(
                    Math.pow(closestRect.left + closestRect.width / 2 - playerCenterX, 2) +
                    Math.pow(closestRect.top + closestRect.height / 2 - playerCenterY, 2)
                );

                const currentDistance = Math.sqrt(
                    Math.pow(currentRect.left + currentRect.width / 2 - playerCenterX, 2) +
                    Math.pow(currentRect.top + currentRect.height / 2 - playerCenterY, 2)
                );

                return currentDistance < closestDistance ? current : closest;
            });
        } else {
            currentTargetWord = null;
            currentTypedWord = '';
            typedWord.textContent = '';
            return;
        }
    }

    if (currentTargetWord && currentTargetWord.hitIndex < currentTargetWord.word.length && 
        currentTargetWord.word[currentTargetWord.hitIndex].toLowerCase() === key.toLowerCase()) {
        currentTypedWord += key;
        currentTargetWord.element.children[currentTargetWord.hitIndex].classList.add('hit');
        currentTargetWord.hitIndex++;
        shootBullet(currentTargetWord);
        currentTargetWord.bulletsInFlight++;
        lettersHitThisWave++;
        totalScore++;
        updateTotalScore();
        
        if (currentTargetWord.hitIndex === currentTargetWord.word.length) {
            currentTypedWord = '';
            currentTargetWord = null;
        }
    }

    typedWord.textContent = currentTypedWord;
    updateDebugInfo();
}

function updateTotalScore() {
    totalScoreValue.textContent = totalScore;
}

function handleWordCompletion(targetWord) {
    zombiesShot++;
    scoreValue.textContent = zombiesShot;
    wordsDefeated++;
    
    const rect = targetWord.element.getBoundingClientRect();
    playBloodSplatter(rect.left + rect.width / 2, rect.top + rect.height / 2);
    
    if (!isMuted) {
        splatSound.currentTime = 0;
        splatSound.play();
    }
    
    words = words.filter(w => w !== targetWord);
    targetWord.element.remove();
    updateWordsLeft();
    checkWaveCompletion();
    updateDebugInfo();
}

function dazeWord(wordObj) {
    wordObj.element.classList.add('dazed');
    wordObj.speed *= 0.75;
    setTimeout(() => {
        wordObj.element.classList.remove('dazed');
        wordObj.speed = wordSpeed * (1 + (wordObj.word.length - 3) * 0.05);
    }, 1000);
}

function checkWaveCompletion() {
    if (wordsDefeated >= waveWordCount) {
        clearInterval(gameInterval);
        isGameActive = false;
        showWaveClearedPopup();
    } else if (words.length === 0 && wordsSpawned < waveWordCount) {
        spawnWordWithDelay();
    }
    updateDebugInfo();
}

function showWaveClearedPopup() {
    waveScore.textContent = lettersHitThisWave;
    waveCleared.style.display = 'block';
    setTimeout(() => {
        waveCleared.style.display = 'none';
        startNextWave();
    }, 3000);
}

function startNextWave() {
    currentWave++;
    waveWordCount += Math.floor(currentWave / 3);
    wordSpeed += 0.05;
    baseSpawnRate = Math.max(750, baseSpawnRate - 50);
    lettersHitThisWave = 0;
    startWave();
}

function isElementInViewport(el) {
    const rect = el.getBoundingClientRect();
    return (
        rect.top >= 0 &&
        rect.left >= 0 &&
        rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&
        rect.right <= (window.innerWidth || document.documentElement.clientWidth)
    );
}

function getVisibleWords() {
    return words.filter(({ element }) => isElementInViewport(element));
}

function updateWordsLeft() {
    wordsLeftValue.textContent = waveWordCount - wordsDefeated;
}

function shootBullet(targetWord) {
    const bullet = document.createElement('div');
    bullet.classList.add('bullet');
    const playerRect = player.getBoundingClientRect();
    const wordRect = targetWord.element.getBoundingClientRect();
    const bullseyeRect = targetWord.element.querySelector('.bullseye').getBoundingClientRect();

    const startX = playerRect.left + playerRect.width / 2;
    const startY = playerRect.top + playerRect.height / 2;
    const endX = bullseyeRect.left + bullseyeRect.width / 2;
    const endY = bullseyeRect.top + bullseyeRect.height / 2;

    bullet.style.left = `${startX}px`;
    bullet.style.top = `${startY}px`;

    const angle = Math.atan2(endY - startY, endX - startX) * (180 / Math.PI);
    bullet.style.transform = `rotate(${angle + 90}deg)`;
    gameContainer.appendChild(bullet);

    if (!isMuted) {
        bulletShotSound.currentTime = 0;
        bulletShotSound.play();
    }

    const animationDuration = 500;
    const startTime = Date.now();

    function animateBullet() {
        const elapsedTime = Date.now() - startTime;
        const progress = Math.min(elapsedTime / animationDuration, 1);

        const currentX = startX + (endX - startX) * progress;
        const currentY = startY + (endY - startY) * progress;

        bullet.style.left = `${currentX - bullet.offsetWidth / 2}px`;
        bullet.style.top = `${currentY - bullet.offsetHeight / 2}px`;

        if (progress < 1) {
            requestAnimationFrame(animateBullet);
        } else {
            bullet.remove();
            targetWord.bulletsInFlight--;
            dazeWord(targetWord);
            
            if (!isMuted && targetWord.hitIndex < targetWord.word.length) {
                bulletHitSound.currentTime = 0;
                bulletHitSound.play();
            }
            
            if (targetWord.bulletsInFlight === 0 && targetWord.hitIndex === targetWord.word.length) {
                handleWordCompletion(targetWord);
            }
        }
    }

    requestAnimationFrame(animateBullet);
}

function playBloodSplatter(x, y) {
    const bloodSplatter = document.createElement('div');
    bloodSplatter.classList.add('blood-splatter');
    bloodSplatter.style.left = `${x - 50}px`;
    bloodSplatter.style.top = `${y - 50}px`;
    gameContainer.appendChild(bloodSplatter);

    setTimeout(() => {
        bloodSplatter.remove();
    }, 1000);
}

function initAudioContext() {
    debugLog("Initializing audio context");
    if (!audioContext) {
        audioContext = new (window.AudioContext || window.webkitAudioContext)();
        debugLog("New audio context created");
    }
    if (audioContext.state === 'suspended') {
        audioContext.resume().then(() => {
            debugLog("Audio context resumed");
            forcePlayMusic();
        }).catch(error => {
            debugLog(`Error resuming audio context: ${error}`);
        });
    } else {
        debugLog(`Audio context state: ${audioContext.state}`);
        forcePlayMusic();
    }
}

function playBackgroundMusic() {
    debugLog("Attempting to play background music");
    if (!isMuted) {
        backgroundMusic.play()
            .then(() => {
                debugLog("Music started successfully");
            })
            .catch(error => {
                debugLog(`Error starting music: ${error}`);
            });
    } else {
        debugLog("Music is muted, not playing");
    }
}

document.addEventListener('keydown', (event) => {
    if (!isGameActive || isPaused) return;

    if (event.key === 'Backspace') {
        if (currentTypedWord.length > 0) {
            currentTypedWord = currentTypedWord.slice(0, -1);
            if (currentTargetWord) {
                currentTargetWord.hitIndex--;
                currentTargetWord.element.children[currentTargetWord.hitIndex].classList.remove('hit');
            }
            if (currentTypedWord.length === 0) {
                currentTargetWord = null;
            }
        }
    } else if (event.key.length === 1) {
        updateTypedWord(event.key);
    }
    typedWord.textContent = currentTypedWord;
    updateDebugInfo();
});

function startWave() {
    isGameActive = true;
    wordsDefeated = 0;
    wordsSpawned = 0;
    words.forEach(({ element }) => element.remove());
    words = [];
    currentTypedWord = '';
    currentTargetWord = null;
    typedWord.textContent = '';
    waveComplete.style.display = 'none';
    gameOver.style.display = 'none';
    waveCleared.style.display = 'none';
    waveValue.textContent = currentWave;
    updateWordsLeft();

    gameInterval = setInterval(moveWords, 33);
    spawnWordWithDelay();
    updateDebugInfo();
}

function forcePlayMusic() {
    debugLog("Entering forcePlayMusic function");
    if (isMuted) {
        debugLog("Music is muted, not playing");
        return;
    }
    debugLog("Attempting to play background music");
    backgroundMusic.currentTime = 0;
    let playPromise = backgroundMusic.play();
    if (playPromise !== undefined) {
        playPromise.then(_ => {
            debugLog("Music playback started successfully");
        })
        .catch(error => {
            debugLog(`Music playback failed: ${error}`);
            setTimeout(forcePlayMusic, 1000);
        });
    } else {
        debugLog("Play promise is undefined, browser might not support promises for audio playback");
    }
}

function endGame() {
    isGameActive = false;
    clearInterval(gameInterval);
    finalScoreValue.textContent = totalScore;
    gameOver.style.display = 'flex';
    updateDebugInfo();
    backgroundMusic.pause();
    showStartButton();
}

function hideStartButton() {
    startGameBtn.style.display = 'none';
}

function showStartButton() {
    startGameBtn.style.display = 'block';
    gameOver.style.display = 'none';
    waveComplete.style.display = 'none';
    waveCleared.style.display = 'none';
}

function initGame(){
    debugLog("Initializing game");
    zombiesShot = 0;
    totalScore = 0;
    scoreValue.textContent = zombiesShot;
    totalScoreValue.textContent = totalScore;
    currentWave = 1;
    waveWordCount = 5;
    wordSpeed = 1.0;
    baseSpawnRate = 1500;
    lettersHitThisWave = 0;
    
    startWave();
    debugLog("Calling forcePlayMusic from initGame");
    forcePlayMusic();
}

restartBtn.addEventListener('click', () => {
    hideStartButton();
    initGame();
    playBackgroundMusic();
});

startGameBtn.addEventListener('click', () => {
    debugLog("Start game button clicked");
    hideStartButton();
    initAudioContext();
    initGame();
    debugLog("Calling forcePlayMusic from start button click");
    forcePlayMusic();
});

showStartButton();
</script>

<a href="https://wordsmasher.io/leaderboard" style="color: #FFD700; text-shadow: 0 0 5px #FFD700;">Zombie Slayer Hall of Fame</a>
<a href="https://wordsmasher.io/tutorial" style="color: #FFD700; text-shadow: 0 0 5px #FFD700;">Cowboy Survival Guide</a>
<a href="https://wordsmasher.io/settings" style="color: #FFD700; text-shadow: 0 0 5px #FFD700;">Apocalypse Settings</a>
</body></html>
